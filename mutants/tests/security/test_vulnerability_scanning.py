import pytest
import subprocess
import json
import os
from pathlib import Path
from unittest.mock import patch, MagicMock


class TestVulnerabilityScanning:
    """Test vulnerability scanning using bandit"""

    def test_bandit_scan_no_high_severity_issues(self):
        """Test that bandit scan finds no high severity issues"""
        # Run bandit on the src directory
        result = subprocess.run(
            ['bandit', '-r', 'src/', '-f', 'json', '-o', '/dev/null'],
            capture_output=True,
            text=True,
            cwd=Path(__file__).parent.parent.parent
        )

        # Parse the JSON output
        try:
            bandit_output = json.loads(result.stdout)
            high_severity_issues = [
                issue for issue in bandit_output.get('results', [])
                if issue.get('issue_severity') == 'HIGH'
            ]

            # Assert no high severity issues
            assert len(high_severity_issues) == 0, f"Found {len(high_severity_issues)} high severity issues: {high_severity_issues}"

        except json.JSONDecodeError:
            # If bandit output is not JSON, check return code
            assert result.returncode == 0, f"Bandit scan failed: {result.stderr}"

    def test_bandit_scan_medium_severity_limit(self):
        """Test that bandit scan has acceptable medium severity issues"""
        result = subprocess.run(
            ['bandit', '-r', 'src/', '-f', 'json'],
            capture_output=True,
            text=True,
            cwd=Path(__file__).parent.parent.parent
        )

        try:
            bandit_output = json.loads(result.stdout)
            medium_severity_issues = [
                issue for issue in bandit_output.get('results', [])
                if issue.get('issue_severity') == 'MEDIUM'
            ]

            # Allow up to 10 medium severity issues (configurable threshold)
            max_allowed_medium = int(os.getenv('MAX_MEDIUM_SEVERITY_ISSUES', '10'))
            assert len(medium_severity_issues) <= max_allowed_medium, \
                f"Found {len(medium_severity_issues)} medium severity issues, max allowed: {max_allowed_medium}"

        except json.JSONDecodeError:
            pytest.skip("Bandit output not in expected JSON format")

    def test_bandit_scan_excludes_test_files(self):
        """Test that bandit scan properly excludes test files"""
        result = subprocess.run(
            ['bandit', '-r', 'tests/', '-f', 'json'],
            capture_output=True,
            text=True,
            cwd=Path(__file__).parent.parent.parent
        )

        # Test files should have fewer security issues or be excluded
        try:
            bandit_output = json.loads(result.stdout)
            test_issues = bandit_output.get('results', [])

            # Test files might have some issues but should be minimal
            assert len(test_issues) < 50, f"Too many issues in test files: {len(test_issues)}"

        except json.JSONDecodeError:
            # If no JSON output, that's also acceptable for test files
            pass

    def test_bandit_configuration_exists(self):
        """Test that bandit configuration file exists"""
        config_files = ['.bandit', 'bandit.yaml', 'pyproject.toml']
        config_exists = any(Path(f).exists() for f in config_files)

        assert config_exists, "No bandit configuration file found"

    def test_security_best_practices(self):
        """Test adherence to security best practices"""
        # Check for common security anti-patterns in source files
        src_dir = Path(__file__).parent.parent.parent / 'src'

        insecure_patterns = [
            'eval(',
            'exec(',
            'pickle.loads(',
            'subprocess.call(',
            'os.system(',
            'input(',
        ]

        found_issues = []

        for py_file in src_dir.rglob('*.py'):
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()

                for pattern in insecure_patterns:
                    if pattern in content:
                        found_issues.append(f"{py_file}: {pattern}")

            except (UnicodeDecodeError, IOError):
                continue

        # Allow some patterns in test files or controlled environments
        critical_issues = [issue for issue in found_issues if 'test' not in str(issue).lower()]

        assert len(critical_issues) == 0, f"Found insecure patterns: {critical_issues}"

    def test_dependency_vulnerability_scan(self):
        """Test dependency vulnerability scanning with safety"""
        result = subprocess.run(
            ['safety', 'check', '--json'],
            capture_output=True,
            text=True,
            cwd=Path(__file__).parent.parent.parent
        )

        if result.returncode == 0:
            # No vulnerabilities found
            return

        try:
            safety_output = json.loads(result.stdout)
            vulnerabilities = safety_output if isinstance(safety_output, list) else []

            # Filter for high/critical severity
            high_critical = [
                vuln for vuln in vulnerabilities
                if vuln.get('severity') in ['high', 'critical']
            ]

            assert len(high_critical) == 0, f"Found {len(high_critical)} high/critical vulnerabilities: {high_critical}"

        except json.JSONDecodeError:
            pytest.skip("Safety output not in expected JSON format")

    @patch('subprocess.run')
    def test_bandit_scan_mocked(self, mock_subprocess):
        """Test bandit scan with mocked subprocess for CI environments"""
        mock_result = MagicMock()
        mock_result.stdout = json.dumps({
            'results': [
                {'issue_severity': 'LOW', 'test_id': 'B101'},
                {'issue_severity': 'MEDIUM', 'test_id': 'B102'},
            ]
        })
        mock_result.returncode = 0
        mock_subprocess.return_value = mock_result

        # This would normally call the real bandit
        result = subprocess.run(['bandit', '-r', 'src/'], capture_output=True, text=True)

        assert result.returncode == 0
        output = json.loads(result.stdout)
        assert len(output['results']) == 2

    def test_vulnerability_scan_integration(self):
        """Integration test for vulnerability scanning pipeline"""
        # This test ensures the entire vulnerability scanning pipeline works
        scan_results = {
            'bandit_issues': 0,
            'safety_vulnerabilities': 0,
            'custom_checks': 0
        }

        # In a real implementation, this would run all scans
        # For now, just verify the structure
        assert isinstance(scan_results, dict)
        assert all(key in scan_results for key in ['bandit_issues', 'safety_vulnerabilities', 'custom_checks'])


class TestSecurityConfiguration:
    """Test security configuration and settings"""

    def test_security_headers_configuration(self):
        """Test that security headers are properly configured"""
        # Check if security middleware or headers are configured
        config_file = Path(__file__).parent.parent.parent / 'src' / 'core' / 'app_config.py'

        if config_file.exists():
            with open(config_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Look for security-related configurations
            security_indicators = [
                'security',
                'headers',
                'cors',
                'helmet',
                'hsts'
            ]

            found_indicators = [indicator for indicator in security_indicators if indicator.lower() in content.lower()]

            # At minimum, should have some security configuration
            assert len(found_indicators) > 0, "No security configuration found in app_config.py"

    def test_environment_security(self):
        """Test environment variable security"""
        # Check for secure environment variable handling
        sensitive_patterns = [
            'password',
            'secret',
            'key',
            'token'
        ]

        env_file = Path(__file__).parent.parent.parent / '.env'

        if env_file.exists():
            with open(env_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Check that sensitive data is not hardcoded
            for pattern in sensitive_patterns:
                assert f'{pattern.upper()}=' not in content, f"Potential hardcoded {pattern} in .env file"

    def test_logging_security(self):
        """Test that logging doesn't expose sensitive information"""
        log_file = Path(__file__).parent.parent.parent / 'src' / 'core' / 'logging.py'

        if log_file.exists():
            with open(log_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Check for secure logging practices
            insecure_patterns = [
                'password',
                'api_key',
                'secret'
            ]

            for pattern in insecure_patterns:
                assert f'log.{pattern}' not in content.lower(), f"Potential sensitive data logging: {pattern}"